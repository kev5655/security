<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <input type="number" placeholder="Type something...">
    <button id="sendBtn">Send</button>
    <a id="output"></a>

    <script type="module">
        // import init, { encrypt } from "./pkg/my_wasm_lib.js";
        import init, {
            Shortint,
            ShortintParameters,
            ShortintParametersName,
        } from "./node_modules/tfhe/tfhe.js";

        await init();

        // Get the seed value from the server to generate the same client key
        let clientKey;
        try {
            console.log("Fetching seed from server...");
            const resp = await fetch("http://localhost:8080/api/v1/registration");

            if (!resp.ok) {
                throw new Error(`HTTP error! status: ${resp.status}`);
            }

            const jsonData = await resp.json();
            const { seed } = jsonData;

            console.log("Seed received:", seed);

            if (!seed) {
                throw new Error("No seed received from server");
            }

            // Use the same seed to generate the client key deterministically
            console.log("Generating client key from seed...");

            // Keep the seed as a BigInt for the whole process
            const seedBigInt = BigInt(seed);
            // Split the seed into high and low u64 values for the API
            const seedLowBytes = seedBigInt & BigInt("0xFFFFFFFFFFFFFFFF");
            const seedHighBytes = seedBigInt >> BigInt(64);

            // Define the parameters - MUST match the backend parameters
            const params = new ShortintParameters(ShortintParametersName.PARAM_MESSAGE_2_CARRY_2_KS_PBS);

            // Generate the client key using the seed and parameters - pass BigInts directly
            clientKey = Shortint.new_client_key_from_seed_and_parameters(
                seedHighBytes,
                seedLowBytes,
                params
            );
            console.log("Client key successfully generated from seed");

        } catch (error) {
            console.error("Error processing client key:", error);
        }

        // Encrypt on button click
        document.getElementById("sendBtn").addEventListener("click", async () => {
            try {
                if (!clientKey) {
                    throw new Error("No client key available. Please reload the page.");
                }

                const x = Number(document.querySelector('input[type="number"]').value);

                // TFHE wants BigInts for encryption
                console.log("Encrypting value on client side:", x);

                // Create a ciphertext using the client key - proper FHE approach
                const ct = Shortint.encrypt(clientKey, BigInt(x));
                console.log("Created ciphertext object:", ct);

                // Serialize the ciphertext for transport
                const serialized = Shortint.serialize_ciphertext(ct);

                // Convert to typed array for processing
                const typedArray = new Uint8Array(serialized);

                // Base64 encode for JSON transport
                const base64Encoded = btoa(String.fromCharCode(...typedArray));

                // Set diagnose mode to true for compatibility
                const diagnoseMode = true;

                const response = await fetch("http://localhost:8080/api/v1/vote/0", {
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        vote: base64Encoded,
                        metadata: {
                            diagnose_mode: diagnoseMode,
                            raw_value: x // Send the raw value for diagnostic purposes
                        }
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const result = await response.json();
                console.log("Vote result:", result);

                // Display the decrypted result
                const decryptedValue = result.result_dec[0];
                console.log("Current tally:", decryptedValue);

                // Update UI
                document.getElementById("output").textContent = `Vote submitted successfully! Current tally: ${decryptedValue}`;
                document.getElementById("output").style.color = "green";
            } catch (error) {
                console.error("Error sending vote:", error);
                document.getElementById("output").textContent = "Error: " + error.message;
                document.getElementById("output").style.color = "red";
            }
        });
    </script>
</body>

</html>